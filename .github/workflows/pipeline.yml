name: Pipeline

on:
  push:

env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      old_version: ${{ steps.old-version.outputs.old_version }}
      new_version: ${{ steps.new-version.outputs.new_version }}
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-teraform@v3
        with:
          terraform_wrapper: false
      - id: plan
        run: terraform plan -no-color
      - id: old-version
        run: echo "old_version=${{ steps.plan.outputs.current_version }}" >> $GITHUB_OUTPUT
      - id: apply
        run: terraform apply -auto-approve -no-color
      - id: new-version
        run: echo "new_version=${{ steps.apply.outputs.current_version }}" >> $GITHUB_OUTPUT

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: needs.build.outputs.old_version != needs.build.outputs.new_version
    steps:
      - uses: actions/checkout@v4
      - name: Generate JSON File for Deployment
        run: |
          cat <<EOF >deployment.json
          {
              "version": 0.0,
              "Resources": [{
                  "TargetService": {
                      "Type": "AWS::Lambda::Function",
                      "Properties": {
                          "Name": "MyLambdaFunction",
                          "Alias": 'live',
                          "CurrentVersion": "${{ needs.build.outputs.old_version }}",
                          "TargetVersion": "${{ needs.build.outputs.new_version }}"
                      }
                  }
              }]
          }
          EOF
      - name: Deploy
        run: |
          aws deploy create-deployment --cli-input-json file://deployment.json
